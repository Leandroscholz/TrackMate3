package net.trackmate.graph;

import net.trackmate.graph.FeatureRegistry.DuplicateKeyException;

/**
 * TODO
 *
 * @param <M>
 * @param <V>
 * @param <F>
 *
 * @author Tobias Pietzsch &lt;tobias.pietzsch@gmail.com&gt;
 */
public abstract class VertexFeature< M, V extends Vertex< ? >, F extends FeatureValue< ? > >
{
	private final String key;

	/**
	 * Unique ID. These IDs are generated by FeatureRegistry, starting from 0.
	 * As long as there are not excessively many VertexFeatures, the ID can be
	 * used as an index to look up features in a list instead of a map.
	 */
	private final int id;

	protected VertexFeature( final String key ) throws DuplicateKeyException
	{
		this.key = key;
		this.id = FeatureRegistry.getUniqueVertexFeatureId( key );
		FeatureRegistry.registerVertexFeature( this );
	}

	public String getKey()
	{
		return key;
	}

	/*
	 * Following part is for the graph to create feature maps, initialize
	 * features, serialize, etc...
	 */

	protected abstract M createFeatureMap( final ReadOnlyGraph< V, ? > graph );

	public abstract F createFeatureValue( V vertex, GraphFeatures< V, ? > graphFeatures );

	protected abstract FeatureCleanup< V > createFeatureCleanup( M featureMap );

	public abstract UndoFeatureMap< V > createUndoFeatureMap( M featureMap );

	public int getUniqueFeatureId()
	{
		return id;
	}

	/**
	 * When a vertex is deleted it must be removed from all feature maps. This
	 * can be done by {@link #delete(Object)}
	 *
	 * @param <V>
	 *            vertex type
	 */
	public static interface FeatureCleanup< V >
	{
		public void delete( final V vertex );
	}

	/**
	 * Backup and restore vertex features by storing them in a map with {@code int} keys.
	 * This is used for implementing undo/redo (hence the name).
	 *
	 * @param <V>
	 *            vertex type
	 */
	public static interface UndoFeatureMap< V >
	{
		/**
		 * Store the feature value of {@code vertex} with the key {@code undoId}.
		 *
		 * @param undoId
		 * @param vertex
		 */
		public void store( int undoId, V vertex );

		/**
		 * Retrieve the feature value stored with key {@code undoId} and set it
		 * in {@code vertex}. If there is no value associated with
		 * {@code undoId}, clear the feature in {@code vertex}.
		 *
		 * @param undoId
		 * @param vertex
		 */
		public void retrieve( int undoId, V vertex );

		/**
		 * Store the feature value of {@code vertex} with the key {@code undoId},
		 * and replace it with the feature value currently stored with key
		 * {@code undoId}. If there is no value currently associated with
		 * {@code undoId}, clear the feature in {@code vertex}.
		 *
		 * @param undoId
		 * @param vertex
		 */
		public void swap( int undoId, V vertex );

		/**
		 * Clear the feature value associated with key {@code undoId} (if any).
		 *
		 * @param undoId
		 */
		public void clear( int undoId );
	}

	protected static class NotifyValueChange< V extends Vertex< ? > >
	{
		private final GraphFeatures< V, ? > graphFeatures;

		private final VertexFeature< ?, V, ? > feature;

		private final V vertex;

		public NotifyValueChange( final GraphFeatures< V, ? > graphFeatures, final VertexFeature< ?, V, ? > feature, final V vertex )
		{
			this.graphFeatures = graphFeatures;
			this.feature = feature;
			this.vertex = vertex;
		}

		public void notifyBeforeFeatureChange()
		{
			graphFeatures.notifyBeforeFeatureChange( feature, vertex );
		}
	}

	@Override
	public int hashCode()
	{
		return id;
	}

	@Override
	public boolean equals( final Object obj )
	{
		return obj instanceof VertexFeature
				&& ( ( VertexFeature< ?, ?, ? > ) obj ).key.equals( key );
	}

	@Override
	public String toString()
	{
		return getClass().getName() + "(\"" + key + "\")";
	}
}
