package net.trackmate.graph;

import net.trackmate.graph.FeatureRegistry.DuplicateKeyException;

// Features must have unique keys!
// TODO: move Features to net.trackmate.graph? requires making methods public, but this is quite general.
public abstract class VertexFeature< M, V extends Vertex< ? >, F extends FeatureValue< ? > >
{
	private final String key;

	/**
	 * Unique ID. These IDs are generated by FeatureRegistry, starting from 0.
	 * As long as there are not excessively many VertexFeatures, the ID can be
	 * used as an index to look up features in a list instead of a map.
	 */
	private final int id;

	protected VertexFeature( final String key ) throws DuplicateKeyException
	{
		this.key = key;
		this.id = FeatureRegistry.getUniqueVertexFeatureId( key );
		FeatureRegistry.registerVertexFeature( this );
	}

	public String getKey()
	{
		return key;
	}

	/*
	 * Following part is for the graph to create feature maps, initialize
	 * features, serialize, etc...
	 */

	protected abstract M createFeatureMap( final ReadOnlyGraph< V, ? > graph );

	protected abstract F createFeatureValue( M featureMap, V vertex );

	protected abstract FeatureCleanup< V > createFeatureCleanup( M featureMap );

	// TODO: for storing feature values for undo/redo
//	protected TIntObjectMap< F > createIdFeatureMap();

	// TODO: remove?
//	protected int getUniqueId()
//	{
//		return id;
//	}

	public static interface FeatureCleanup< V >
	{
		public void delete( final V vertex );
	}

	@Override
	public int hashCode()
	{
		return id;
	}

	@Override
	public boolean equals( final Object obj )
	{
		return obj instanceof VertexFeature
				&& ( ( VertexFeature< ?, ?, ? > ) obj ).key.equals( key );
	}

	@Override
	public String toString()
	{
		return getClass().getName() + "(\"" + key + "\")";
	}
}
